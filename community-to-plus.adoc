= Community Ingress Migration
Mark Boddington <mark.boddington@nignx.com>
:description: Guide to migrate from CNCF ingress-nginx to NGINX Inc kubernetes-ingress
:doctype: article
:url-repo: https://github.com/TuxInvader/nginx-plus-migration
:toc: preamble

.Abstract
There are two primary NGINX based Ingress Controllers available for the Kubernetes platform. One is built and managed by the CNCF community, which we'll refer to as "Community Ingress" (https://github.com/kubernetes/ingress-nginx[ingress-nginx]) and the other is built and maintained by NGINX, which we'll refer to as "NGINX Ingress Controller" or NIC  (https://github.com/nginxinc/kubernetes-ingress[kubernetes-ingress]).

This document attempts to describe each of the Community Ingress controller annotations, and provide the best alternative option for use with NGINX Ingress Controller (NIC).

It should be a useful resource for anyone interesting in migrating from Community Ingress to the NGINX Plus Ingress Controller.

I also recommend that you read this great post about migrating on the https://www.nginx.com/blog/migrating-from-community-ingress-controller-to-f5-nginx-ingress-controller/[NGINX blog], and download our free ebook https://www.nginx.com/resources/library/managing-kubernetes-traffic-with-f5-nginx-practical-guide[Managing Kubernetes Traffic with F5 NGINX]. Both provide a lot of help and useful guidance.

[IMPORTANT]
.Ingress vs CRDs
NGINX Ingress Controller (NIC) supports standard Ingress resources with annotations, and also advanced Custom Resources. We highly recommend that you adopt the CRs because they offer better features and are fully validated by the K8s API. Ingress annotations are KVP metadata, prone to error, and fail slow.

== Advantages of NGINX Plus Ingress

* commercial support
* NGINX App Protect (Web Application Firewall)
* NAP-DoS (AI/ML Application DoS protection)
* Advanced Load Balancing capabilities through CRDs

== Configuration notes

=== snippets
Many of the configurations outlined below require the use of code snippets: `http-snippets`, `server-snippets` or `location-snippets`. You will need to add the `-enable-snippets` option to the NIC deployment otherwise Ingress/CRDs will be rejected.

== Annotations

=== app-root
[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/app-root
h|Details| Creates a redirect for the root url (/) to the given path.
h|Ingress | nginx.org/server-snippets
2+l| 
    nginx.org/server-snippets: \|
      location / {
        return 302 /coffee;
      }
h|CRD| routes.*.action.redirect
2+l|
    routes:
    - path: /
      action:
        redirect:
          url: ${host}/coffee
          code: 301
|===

=== affinity
[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/affinity
h|Details| Enables cookie based session persistence
h|Ingress | nginx.com/sticky-cookie-services: "service1[;service2;...]"
2+l|
    nginx.com/sticky-cookie-services: "serviceName=coffee-svc cookieName expires=1h httponly secure path=/coffee
h|CRD| upstream.SessionCookie
2+l|
    upstreams:
    - name: tea
      service: tea-svc
      port: 80
      sessionCookie:
        enable: true
        name: srv_id
        path: /
        expires: 1h
        domain: .example.com
        httpOnly: false
        secure: true
|===

For more information see: https://github.com/nginxinc/kubernetes-ingress/tree/v2.2.2/examples/session-persistence

=== affinity-mode

There is no equivalent in the NGINX Ingress, the behavior of NGINX is to always persist the client to the upstream while it is available. This is the same as the "persistent" mode in community.

=== affinity-canary-behavior

There is no equivalent in the NGINX Ingress, the behavior of NGINX is to always persist the client to the upstream while it is available. This is the same as the "sticky" mode in community.

=== auth-realm
[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/auth-realm
h|Details| This is one of several annotations which can be used together to enable basic or digest authentication
h|Ingress | nginx.org/server-snippets *or* nginx.org/location-snippets
2+l|
    nginx.org/server-snippets: \|
      auth_basic_user_file /etc/nginx/htpasswd/basic-auth;
      auth_basic "Secure Site";
h|CRD| server-snippets *or* routes.*.location-snippets
2+l|
    spec:
      server-snippets: \|
        auth_basic_user_file /etc/nginx/htpasswd/basic-auth;
        auth_basic "Secure Site";
|===

The above example also requires that the htpasswd file be mounted into the Ingress Controller as a volume. You can create load the htpasswd file in as a secret using `kubectl` eg:

----
kubectl -n nginx-ingress create secret generic basic-auth --from-file=basic-auth
----

You will then need to make adjustments to your Ingress Controller deployment to mount the basic-auth secret, similar to this:

----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-ingress
  namespace: nginx-ingress
spec:
  replicas: 1
  ...
  template:
    metadata:
      ...
    spec:
      volumes:
        - name: basic-auth
          secret:
            secretName: basic-auth
            optional: false
      ...
      containers:
        - name: nginx-ingress
          ...
          volumeMounts:
            - name: basic-auth
              mountPath: /etc/nginx/htpasswd
              readOnly: true
----

=== auth-secret

This annotation references the secret which contains the htpasswd information for basic-auth. With NGINX Ingress, any secrets need to be mounted into the Ingress Controller deployment as volumes. See the <<auth-realm>> section above for details.

=== auth-secret-type

The secret mounted into the NGINX Ingress should be a standard htpasswd file. See <<auth-realm>> for how to mount this secret into the Ingress Controller pods.

=== auth-type

The only auth-type supported is `basic`, we do not have an equivalent annotation. See <<auth-realm>> for a description of how to do basic auth with NGINX Ingress.

=== auth-tls-secret
[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/auth-tls-secret
h|Details| This is one of several annotations to enable client certificate authentication
h|Ingress | nginx.org/server-snippets
2+l|
    nginx.org/server-snippets: \|
      ssl_client_certificate   /etc/nginx/mtls/ca.crt;
      ssl_verify_client        on;
      ssl_verify_depth         2;
      error_page               495 496 = 301 http://foo.bar/cert-fail;
h|CRD| VS Policy: IngressMTLS
2+l|
    apiVersion: k8s.nginx.org/v1
    kind: Policy
    metadata:
      name: client-mtls
    spec:
      ingressMTLS:
        clientCertSecret: ingress-client-ca
        verifyClient: "on"
        verifyDepth: 2
2+l|
    apiVersion: k8s.nginx.org/v1
    kind: VirtualServer
    metadata:
      name: cafe
    spec:
      policies:
      - name: client-mtls
|===

If using the CRD, you can create the policy resource and then apply it to the VirtualServer resource under spec.policies as shown above.

If you are using an Ingress resource and annotation, then you will need to ensure that you mount the CA certificate into the Ingress Controller using a volume mount. eg:

----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-ingress
  namespace: nginx-ingress
spec:
  replicas: 1
  ...
  template:
    metadata:
      ...
    spec:
      volumes:
        - name: ingress-client-ca
        secret:
          secretName: ingress-client-ca
          items:
            - key: ca.crt
              path: ca.crt
      ...
      containers:
        - name: nginx-ingress
          ...
          volumeMounts:
            - mountPath: /etc/nginx/mtls
              name: ingress-client-ca
              readOnly: true

----

=== auth-tls-verify-depth

The number of certificates to check when trying to find the chain-of-trust between the provided CA certificate and the client. This is provided in the `server-snippet` or `policy` see <<auth-tls-secret>> above

=== auth-tls-verify-client

This is passed as an option to `ssl_verify_client` in the snippet or `verifyClient` in the CRD Policy. The possible values are: `on`, `off`, `optional`, `optional_no_ca`. See <<auth-tls-secret>> above.

=== auth-tls-error-page

This is not supported on the CRD `Policy`, but can enabled with `errorPages` on the `VirtualServer` CRD. It can also be enabled with `server-snippets` in the Ingress resource.

[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/auth-tls-error-page
h|Details| Returns a redirect in the event the client certificate authentication fails
h|Ingress | nginx.org/server-snippets
2+l|
    nginx.org/server-snippets: \|
      error_page    495 496 = 301 http://foo.bar/cert-fail;
h|CRD| errorPages on path, or server-snippets
2+l|
    path: /
    errorPages:
    - codes: [495, 496]
      redirect:
        code: 301
        url: http://foo.bar/cert-fail
2+l|
    spec:
      server-snippets: \|
        error_page    495 496 = 301 http://foo.bar/cert-fail;
|===

See the <<auth-tls-secret>> section for the full mTLS example.

=== auth-tls-pass-certificate-to-upstream

[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream
h|Details| When client cert auth is in use, this boolean enables passing the client cert information to the upstream in the header ssl-client-cert
h|Ingress | nginx.org/server-snippets
2+l|
    nginx.org/server-snippets: \|
      proxy_set_header ssl_client_cert $ssl_client_raw_cert;
      proxy_set_header ssl-client-issuer-dn $ssl_client_i_dn;
      proxy_set_header ssl-client-subject-dn $ssl_client_s_dn;
      proxy_set_header ssl-client-verify $ssl_client_verify;
h|CRD| action.proxy.requestHeaders
2+l|
    action:
      proxy:
        upstream: webapp
        requestHeaders:
          set:
          - name: ssl-client-subject-dn
            value: ${ssl_client_s_dn}
          - name: ssl-client-issuer-dn
            value: ${ssl_client_i_dn}
          - name: ssl_client_cert
            value: ${ssl_client_raw_cert}
          - name: ssl_client_verify
            value: ${ssl_client_verify}
|===

In the snippet above we sent the raw PEM cert, but you can send any of the client cert variables which NGINX creates in the http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_client_certificate[ngx_http_ssl_module].

The example also sets the other headers which community ingress sends by default: `ssl-client-issuer-dn`, `ssl-client-subject-dn` and `ssl-client-verify`. 

[TIP]
Since NGINX version 1.11.7 - the FAILED result in `ssl_client_verify` changed to `FAILED:reason`

=== auth-tls-match-cn

There is no equivalent for Ingress resources, but we can use a location-snippet on the resource to set a condition based on a variable, and then set that variable with a map in the NGINX ConfigMap.

[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/auth-tls-match-cn
h|Details| Enables a comparison between the subject dn of the client cert and a provided regex
h|Ingress | nginx.org/location-snippets
2+l|
    nginx.org/location-snippets: \|
      if ( $access_allowed = 0 ) {
        return 403 "403 Access Forbidden:\n";
      }
2+l| 
    kind: ConfigMap
    apiVersion: v1
    metadata:
      name: nginx-config
      namespace: nginx-ingress
    data:
      http-snippets: \|
        map $ssl_client_s_dn $access_allowed {
          default          0;
          CN=foo.bar       1;
          ~*CN=.*\.my.org  1;
        }
h|CRD| matches.condition.variable
2+l|
    path: /coffee
    matches:
    - conditions:
      - variable: $ssl_client_s_dn
        value: "CN=foo.bar"
      - variable: $ssl_client_s_dn
        value: "~*CN=.*\.my.org"
      action:
        pass: coffee-post
    action:
      pass: coffee
|===

=== auth-url

TODO - Determine if this uses the `auth_http` directive and provide example if so.

=== auth-cache-key

TODO - See <<auth-url>>

=== auth-cache-duration

TODO - See <<auth-url>>

=== auth-keepalive

TODO - See <<auth-url>>

=== auth-keepalive-requests

TODO - See <<auth-url>>

=== auth-keepalive-timeout

TODO - See <<auth-url>>

=== auth-proxy-set-headers

TODO - See <<auth-url>>

=== auth-snippet

TODO - See <<auth-url>>

=== enable-global-auth

TODO - See <<auth-url>>

=== backend-protocol

NGINX Plus Ingress Controller can be used to load balance HTTP(S) and GRPC(S) upstreams. It does not support using an upstream through AJP or FastCGI protocols.

[TIP]
Instead of using AJP or FastCGI from NGINX, use https://unit.nginx.org[NGINX Unit] as your application server and execute all of your different languages on a common platform. You can then front Unit with NGINX Plus Ingress Controller.

If you *really need* NGINX to load balance FastCGI, then you may be able to build your own configuration and deploy NGINX as a normal workload.

==== HTTP Backend

This is the default, no additional configuration is necessary

==== HTTPS Backend

|===
h|Annotation| nginx.ingress.kubernetes.io/backend-protocol
h|Details| Sets the backend protocol to use with the upstreams (HTTP, HTTPS, GRPC, GRPCS, AJP, FCGI). 
h|Ingress | nginx.org/ssl-services
2+l|
    nginx.org/ssl-services: "tea-svc"
h|CRD| upstreams.*.tls.enable
2+l|
    upstreams:
      - name tea-svc
        tls:
          enable: true
        ...
|===

==== GRPC Backends

[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/backend-protocol
h|Details| Sets the backend protocol to use with the upstreams (HTTP, HTTPS, GRPC, GRPCS, AJP, FCGI). 
h|Ingress | nginx.org/grpc-services
2+l|
    nginx.org/grpc-services: "tea-svc"
h|CRD| upstreams.*.type
2+l|
    upstreams:
      - name: tea-svc
        type: grpc
|===

==== GRPCS Backends

This is a combination of the HTTPS and GRPC options
[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/backend-protocol
h|Details| Sets the backend protocol to use with the upstreams (HTTP, HTTPS, GRPC, GRPCS, AJP, FCGI). 
h|Ingress | nginx.org/grpc-services *and* nginx.org/ssl-services
2+l|
    nginx.org/grpc-services: "tea-svc"
    nginx.org/ssl-services: "tea-svc"
h|CRD| upstreams.*.[type\|tls]
2+l|
    upstreams:
      - name: tea-svc
        type: grpc
        tls:
          enable: true
|===


[TIP]
When dealing with GRPC services, your clients will likely expect to connect to the service using HTTP2, so you should enable `http2` in the NGINX `ConfigMap` and configure TLS termination on the Ingress/CRD

=== canary

The community ingress controller has a number of annotations which control routing traffic to a canary version of the application.

[TIP]
I'll cover a few examples here, but there is a comprehensive guide available in ebook form: https://www.nginx.com/resources/library/managing-kubernetes-traffic-with-f5-nginx-practical-guide[Managing Kubernetes Traffic with F5 NGINX]

==== canary-by-header
[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/canary-by-header
h|Example| nginx.ingress.kubernetes.io/canary-by-header: my-header
h|Details| Enables routing to the canary when the named header is present and has a value of `always` or `never`
h|Ingress | nginx.org/server-snippets
2+l|
    nginx.org/server-snippets: \|
      location /canary {
        internal;
        proxy_pass http://app-canary-svc.namespace/
      }
    nginx.org/location-snippets: \|
      if ( $access_canary = 1 ) {
        rewrite ^(.*)$ /canary/$1
      }
2+l| 
    kind: ConfigMap
    apiVersion: v1
    metadata:
      name: nginx-config
      namespace: nginx-ingress
    data:
      http-snippets: \|
        map $http_my_header $access_canary {
          default          0;
          never            0;
          always           1;
        }
h|CRD|
2+l|
|===

If you are using the Ingress with snippets along with NGINX Service Mesh (NSM), you will need to enable mTLS on the canary location like so:

----
	location /canary {
	  internal;
	  proxy_ssl_certificate /etc/nginx/secrets/spiffe_cert.pem;
	  proxy_ssl_certificate_key /etc/nginx/secrets/spiffe_key.pem;
	  proxy_ssl_trusted_certificate /etc/nginx/secrets/spiffe_rootca.pem;
	  proxy_ssl_server_name on;
	  proxy_ssl_verify on;
	  proxy_ssl_verify_depth 25;
	  proxy_ssl_name app-canary-svc.namespace.svc;
	  proxy_pass https://app-canary-svc.namespace:80/;
	}
----


## template

[cols="1,3"]
|===
h|Annotation| nginx.ingress.kubernetes.io/
h|Details|
h|Ingress |
2+l|
h|CRD|
2+l|
|===
